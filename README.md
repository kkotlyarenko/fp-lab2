# Лабораторная работа №2

Студент: **Котляренко Кирилл Андреевич**  
Группа: **P3309**  
Вариант: **rb-dict-lazy**

## Описание

Реализация словаря (Dictionary) на основе красно-черного дерева (Red-Black Tree) с использованием ленивых вычислений (Lazy Evaluation) на языке OCaml.

## Структура проекта

```
fp-lab2/
├── lib/
│   ├── rb_dict_lazy.ml      # Основная реализация
│   ├── rb_dict_lazy.mli     # Интерфейс модуля
│   └── dune                 # Конфигурация библиотеки
├── test/
│   ├── test_rb_dict_lazy.ml # Unit и property-based тесты
│   └── dune                 # Конфигурация тестов
├── example/
│   ├── example.ml           # Пример использования
│   └── dune                 # Конфигурация примера
├── dune-project             # Конфигурация проекта
└── README.md
```

## Основные возможности

### API функции

1. **Базовые операции**:
   - `empty` - пустой словарь
   - `is_empty` - проверка на пустоту
   - `insert` - добавление элемента
   - `find` - поиск элемента по ключу
   - `mem` - проверка наличия ключа
   - `remove` - удаление элемента

2. **Функции высшего порядка**:
   - `map` - отображение функции на значения
   - `filter` - фильтрация по предикату
   - `fold_left` - левая свертка
   - `fold_right` - правая свертка

3. **Моноид**:
   - `mempty` - нейтральный элемент (пустой словарь)
   - `mappend` - бинарная операция (объединение словарей)

4. **Утилиты**:
   - `of_list` / `to_list` - конвертация в/из списка
   - `size` - размер словаря
   - `equal` - сравнение словарей
   - `to_string` - строковое представление

## Ключевые элементы реализации

### Красно-черное дерево с ленивыми вычислениями

```ocaml
type color = Red | Black

type ('k, 'v) tree =
  | Empty
  | Node of color * ('k, 'v) tree Lazy.t * 'k * 'v * ('k, 'v) tree Lazy.t
```

**Ленивые вычисления**: Поддеревья хранятся как `Lazy.t`, что позволяет откладывать их вычисление до момента необходимости. Это улучшает производительность при работе с большими деревьями.

### Балансировка

Функция `balance` обеспечивает сохранение свойств красно-черного дерева после вставки, обрабатывая 4 случая нарушения балансировки с использованием pattern matching.

### Свойства моноида

Словарь является моноидом с:
- **Нейтральный элемент**: `mempty = Empty`
- **Бинарная операция**: `mappend` объединяет два словаря (при конфликте ключей выбирается значение из правого словаря)
- **Ассоциативность**: `(a ⊕ b) ⊕ c = a ⊕ (b ⊕ c)`
- **Левая идентичность**: `mempty ⊕ a = a`
- **Правая идентичность**: `a ⊕ mempty = a`

## Установка зависимостей

```bash
opam install dune alcotest qcheck
```

Установка зависимостей проекта (только deps):

```bash
opam install . --deps-only --with-test
```

## Сборка и тестирование

### Сборка проекта

```bash
dune build
```

### Запуск тестов

```bash
dune test
```

### Форматирование кода

```bash
dune build @fmt --auto-promote
```

### Очистка

```bash
dune clean
```

### Запуск примера

```bash
dune exec example/example.exe
```

## Тестирование

### Unit тесты

Включают проверку всех базовых операций:
- Вставка и поиск
- Обновление значений
- Удаление элементов
- Map, filter, fold операции
- Операции моноида
- Конвертация списков
- Сравнение словарей

### Property-based тесты (QCheck)

Тестируют следующие свойства:

1. **Корректность insert/find**: Вставленное значение можно найти
2. **Левая идентичность моноида**: `mempty ⊕ x = x`
3. **Правая идентичность моноида**: `x ⊕ mempty = x`
4. **Ассоциативность моноида**: `(x ⊕ y) ⊕ z = x ⊕ (y ⊕ z)`
5. **Map сохраняет размер**: Размер словаря не меняется после map
6. **Filter уменьшает размер**: Размер после filter ≤ исходного размера
7. **Roundtrip через список**: `of_list (to_list x) = x`
8. **Remove удаляет ключ**: После remove ключ не находится
9. **Эквивалентность fold**: `fold_left` и `fold_right` дают одинаковый результат для коммутативных операций

## Пример использования

```ocaml
open Rb_dict_lazy

(* Создание пустого словаря *)
let dict = empty

(* Вставка элементов *)
let dict = dict 
  |> insert 1 "one"
  |> insert 2 "two"
  |> insert 3 "three"

(* Поиск *)
let value = find 2 dict  (* Some "two" *)

(* Map *)
let dict2 = map String.uppercase_ascii dict

(* Filter *)
let dict3 = filter (fun k v -> k > 1) dict

(* Fold *)
let sum = fold_left (fun acc k v -> acc + k) 0 dict  (* 6 *)

(* Объединение словарей *)
let dict4 = mappend dict dict2
```

## Выводы

### Использованные приемы программирования

1. **Ленивые вычисления (Lazy Evaluation)**: 
   - Позволяют отложить вычисление поддеревьев до момента использования
   - Улучшают производительность при работе с большими структурами
   - Особенно эффективны при частичной обработке дерева

2. **Pattern Matching**: 
   - Используется для элегантной реализации балансировки
   - Обрабатывает все 4 случая нарушения инварианта красно-черного дерева
   - Делает код читаемым и поддерживаемым

3. **Неизменяемые структуры данных**: 
   - Каждая операция возвращает новое дерево
   - Упрощает рассуждение о корректности
   - Позволяет безопасно использовать в многопоточном окружении

4. **Полиморфизм**: 
   - Работает с любыми сравнимыми типами ключей
   - Значения могут быть любого типа
   - Реализация полностью параметрическая

5. **Моноид**: 
   - Алгебраическая структура с ассоциативной операцией и нейтральным элементом
   - Позволяет естественно композировать словари
   - Гарантирует предсказуемое поведение при объединении

6. **Property-Based Testing**: 
   - Автоматическая генерация тестовых случаев
   - Проверка алгебраических свойств
   - Повышает уверенность в корректности реализации


